{
  "author": {
    "name": "Dominic Tarr",
    "email": "dominic.tarr@gmail.com",
    "url": "http://dominictarr.com"
  },
  "name": "scuttlebutt",
  "description": "replicate data via scuttlebutt protocol",
  "version": "5.6.7",
  "homepage": "https://github.com/dominictarr/scuttlebutt",
  "repository": {
    "type": "git",
    "url": "git://github.com/dominictarr/scuttlebutt.git"
  },
  "dependencies": {
    "iterate": "0.1.0",
    "duplex": "~1.0.0",
    "stream-serializer": "1.1.2",
    "monotonic-timestamp": "~0.0.8"
  },
  "devDependencies": {
    "macgyver": "~1.10",
    "event-stream": "~3.0",
    "tape": "~0.1.5",
    "request": "~2.16.6"
  },
  "testling": {
    "files": "test/*.js",
    "browsers": {
      "ie": [
        8,
        9,
        10
      ],
      "firefox": [
        17,
        18
      ],
      "chrome": [
        23,
        24
      ],
      "safari": [
        5,
        6
      ],
      "opera": [
        12
      ]
    }
  },
  "scripts": {
    "test": "set -e; for test in test/*.js; do node $test; done"
  },
  "readme": "# scuttlebutt\n\nA base-class for real-time replication.\n\n[![travis](https://secure.travis-ci.org/dominictarr/scuttlebutt.png?branch=master)](https://travis-ci.org/dominictarr/scuttlebutt)\n\n[![browser support](http://ci.testling.com/dominictarr/scuttlebutt.png)](http://ci.testling.com/dominictarr/scuttlebutt)\n\nThis seems like a silly name, but I assure you, this is real science. \nRead this: http://www.cs.cornell.edu/home/rvr/papers/flowgossip.pdf \n\nOr, if you're lazy: http://en.wikipedia.org/wiki/Scuttlebutt (laziness will get you nowhere, btw)\n\n## Subclasses\n\nScuttlebutt is intended to be subclassed into a variety of data-models.\n\nTwo implementations are provided as examples [scuttlebutt/model](#scuttlebuttmodel) and\n[scuttlebutt/events](#scuttlebuttevents)\n\nsubclasses:\n\n  * [crdt](https://github.com/dominictarr/crdt) higher-level, with sets and sequences.\n  * [r-array](https://github.com/dominictarr/r-array) Replicatable Array.\n  * [r-edit](https://github.com/dominictarr/r-edit) Collaborative Text Editing.\n  * [append-only](https://github.com/Raynos/append-only) news feed.\n  * [scuttlebucket](https://github.com/dominictarr/scuttlebucket) combine multiple scuttlebutts into one.\n  * [expiry-model](https://github.com/Raynos/expiry-model) memory capped model with expiring keys.\n  * [r-value](https://github.com/dominictarr/r-value) replicate a single value.\n\n### Replication\n\nAny Scuttlebutt subclass is replicated with createStream.\n\n``` js\nvar Model = require('scuttlebutt/model')\nvar net   = require('net')\n\nvar s = new Model()\nvar z = new Model()\n\nnet.createServer(function (stream) {\n\n  stream.pipe(s.createStream()).pipe(stream)\n\n}).listen(8000, function () {\n\n  var stream = net.connect(8000)\n  stream.pipe(z.createStream()).pipe(stream)  \n\n})\n```\n\n### Gotchas\n\nScuttlebutt is always duplex.\nScuttlebutt does a handshake on connecting to another scuttlebutt,\nand this won't work unless both sides are connected.\n\n#### Right\n\n``` js\nstream.pipe(model.createStream()).pipe(stream)\n```\n\n#### WRONG!\n\n``` js\nwrongStream.pipe(model2.createStream())\n```\n\nAlso, when creating a server, scuttlebutt needs a stream for EACH connection.\n\n#### Right\n\n``` js\nnet.createServer(function (stream) {\n  stream.pipe(model.createStream()).pipe(stream)\n}).listen(port)\n```\n\n#### WRONG!\nthis will use one stream for many connections!\n``` js\nvar wrongStream = model.createStream()\nnet.createServer(function (stream) {\n  stream.pipe(wrongStream).pipe(stream)\n}).listen(port)\n```\n\n### Errors and use in PRODUCTION\n\nIf have are using scuttlebutt in production, you must register\non `'error'` listener in case someone sends invalid data to it.\n\n** Any stream that gets parsed should have an error listener! **\n\n``` js\nnet.createServer(function (stream) {\n  var ms = m.createStream()\n  stream.pipe(ms).pipe(stream)\n  ms.on('error', function () {\n    stream.destroy()\n  })\n  stream.on('error', function () {\n    ms.destroy()\n  })\n}).listen(9999)\n```\n\nOtherwise, if someone tries to connect to port `9999` with a different\nprotocol (say, HTTP) this will emit an error. You must handle this and\nclose the connection / log the error.\n\nAlso, you should handle errors on `stream`, stream may error if the client\nresponsible for it crashes.\n\n### Persistence\n\nPersist by saving to at least one writable stream.\n\n``` js\nvar Model = require('scuttlebutt/model') //or some other subclass...\nvar fs = require('fs')\nvar m = new Model()\n\n//stream FROM disk.\nfs.createReadStream(file).pipe(m.createWriteStream())\n\n//stream TO disk.\nm.on('sync', function () {\n  m.createReadStream().pipe(fs.createWriteStream(file))\n})\n```\nUse `on('sync',...` to wait until the persisted state is in the file\nbefore writing to disk.\n(Make sure you rotate files, else there is an edge case where if the process\ncrashes before the history has been written some data will be lost\n/*this is where link to module for that will go*/)\n\nYou may use [kv](https://github.com/dominictarr/kv) to get streams \nto local storage.\n\n## read only mode.\n\nSometimes you want to use scuttlebutt to send data one way,\nfrom a `master` instance to a `slave` instance.\n\n``` js\nvar s1 = master.createStream({writable: false, sendClock: true})\nvar s2 = slave.createStream({readable: false, sendClock: true})\n```\n\n`master` will emit updates, but not accept them, over this stream.\nThis checking is per stream - so it's possible to attach `master` to \nanother master node and have master nodes replicate each way.\n\n## Implementing Custom Scuttlebutts\n\nThe user must inherit from `Scuttlebutt` and provide an implementation of `history()` and `applyUpdate()`.\n\n### Scuttlebutt#history(sources)\n\n`sources` is a hash of source_ids: timestamps. \nHistory must return an array of all known events from all sources\nThat occur after the given timestamps for each source.\n\nThe array MUST be in order by timestamp.\n\n### Scuttlebutt#applyUpdate (update)\n\nPossibly apply a given update to the subclasses model.\nReturn 'true' if the update was applied. (See scuttlebutt/model.js\nfor an example of a subclass that does not apply every update.)\n\n### Scuttlebutt#createStream (opts)\n\nCreate a duplex stream to replicate with a remote endpoint.\n\nThe stream returned here emits a special `'header'` event with the id of the\nlocal and remote nodes and the vector clock. You can set metadata on the header\nobject using `opts.meta`.\n\n#### Examples\n\nConnect two `Model` scuttlebutts locally.\n\n``` js\nvar Model = require('scuttlebutt/model')\n\nvar a = new Model()\nvar b = new Model()\n\na.set(key, value)\n\nb.on('update', console.log)\n\nvar s = a.createStream()\ns.pipe(b.createStream()).pipe(s)\n```\n\n### scuttlebutt/events\n\nA reliable event emmitter. Multiple instances of an emitter\nmay be connected to each other and will remember events,\nso that they may be resent after a disconnection or crash.\n\nWith this approach it is also possible to persist events to disk,\nmaking them durable over crashes.\n\n``` js\nvar Emitter = require('scuttlebutt/events')\nvar emitter = new Emitter()\n```\n\n#### emit (event, data)\n\nEmit an event. Only one argument is permitted.\n\n#### on (event, listener)\n\nAdd an event listener.\n\n### scuttlebutt/model\n\nA replicateable `Model` object.\n\n``` js\nvar Model = require('scuttlebutt/model')\nvar model = new Model()\n```\n\n\n#### get (key)\n\nGet a property.\n\n#### set (key, value)\n\nSet a property.\n\n#### on('update', function (key, value, source))\n\nEmmitted when a property changes. \nIf `source !== this.id`\nthen it was a remote update.\n\n## Protocol\n\nMessages are sent in this format:\n\n``` js\n[change, timestamp, source]\n```\n\n`source` is the id of the node which originated this message.\nTimestamp is the time when the message was created. \nThis message is created using `Scuttlebutt#localUpdate(key, value)`.\n\nWhen two `Scuttlebutts` are piped together, they both exchange their current list\nof sources. This is an object of `{source_id: latest_timestamp_for_source_id}`\nAfter receiving this message, `Scuttlebutt` sends any messages not yet \nknown by the other end. This is the heart of Scuttlebutt Reconciliation.\n\n## Security\n\nScuttlebutt has an (optional) heavy duty security model using public keys. \nThis enables a high level of security even in peer-to-peer applications.\nYou can be sure that a given message is from the node that sent it, \neven if you did not receive the messasge from them directly.\n\n## Enabling Security\n\n``` js\nvar model = require('scuttlebutt/model')\nvar security = require('scuttlebutt/security')\nvar keys = {}\nvar m = new Model(security(keys, PRIVATE, PUBLIC))\n```\n\n## Security API\n\nWhen security is enabled, each scuttlebutt message is signed with a private key.\nIt is then possible for any scuttlebutt instance to be confidant about the\nauthenticity of the message by verifying it against the source's public key.\n\nThis is possible even if the verifying node received the message from an intermediate node.\n\nSecurity is activated by passing in a security object to the contructor of a scuttlebutt\nsubclass. \n\nUse the included implementation:\n\n``` js\nvar security = require('scuttlebutt/security')(keys, PRIVATE, PUBLIC)\nvar Model = require('scuttlebutt/model')\n\nvar m = new Model(security)\n```\n\nSee \n[scuttlebutt/security.js](https://github.com/dominictarr/scuttlebutt/blob/master/security.js)\nfor a simple example implementation.\n\n`sign(update)` should sign the `update` with the instance's private key.\n`verify(update, cb)` should verify the update, using public key associated with the\n`source` field in the update. Verification may be asyncronous. `verify` must callback\n`cb(err, boolean)` where boolean indicates whether or not the signature is valid.\nOnly callback in error in the most extreme circumstances. \nIf there was no known key for the required source then that should be treated as a \nverification failure. If it is not possible to reach the key database (or whatever)\nthen the request should be retried until it is available. \n\n> Note: although the API supports asyncronous verification, \n> it's probably a good idea to load keys into memory so that messages can be verified\n> and signed syncronously.\n\n`createId()` returns a new id for the current node. This is used in the example security \nimplementation to return a id that is a hash of the public key. This makes it impossible\nfor rogue nodes to attempt to associate a old node id with a new public key.\n\n## Generating Keys.\n\nGenerate an ssh private key, and a PEM encoded public key.\n```\nssh-keygen -f $KEYNAME -b $LENGTH -N $PASSWORD -q\nssh-keygen -e -f $KEYNAME.pub -m PEM > $KEYNAME.pem\n\n```\n`$LENGTH` must be `>= 786`, shorter is faster but less secure.\npassword may be empty `''`.\n\n`$KEYNAME` is the private key, and `$KEYNAME.pem` is the public key\nto use with Scuttlebutt.\n\n",
  "readmeFilename": "README.markdown",
  "bugs": {
    "url": "https://github.com/dominictarr/scuttlebutt/issues"
  },
  "_id": "scuttlebutt@5.6.7",
  "_from": "scuttlebutt@"
}
