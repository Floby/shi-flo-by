var h = require('h')

//hmm, what about a writable widget?
//use text entry boxes instead - and 
//hmm, - in that case, we must update the elements differently...

//just taking a template function seems good at first...
//but it's awkard when the object changes, and want to run the template again,
//but this time as an update...

//hmm, maybe the way to get two way-bindings is the way knockout does it?
//observables? hmm, and what about angular?
//could I add a wrapper to make this knockoutable?
//or angularable?

//backbone will be easy...

function observable (key) {
  var model = this
  return function (value) {
    if('function' !== typeof value)
      return model.set(key, value)
    model.on('change:'+key, value)
    //maybe this is the simplest way to implement remove?
    return function () {
      model.removeListener('change:'+key, value)
    }
  }
}

module.exports = function (model, opts, template) {
  if('function' === typeof opts)
    template = opts, opts = {}
  
  opts = opts || {}

  var black = opts.blacklist
  var white = opts.whitelist

  //the reason that table based layouts are said to be bad
  //is not the case anymore -- that was about SEO,
  //and we are building widgets for Applications, these "pages" 
  //are not intended to be indexed - they change in realtime.

  //also, the default layout is behaves how we need!

  //unfortunately, function, style, and content are not even
  //separated between css, html, and javascript.
  //A table is a good choice, because it doesn't require structural css.

  var table = h('table.scuttlebutt_widget')

  template = template || opts.template || function (observer) {
    //hmm, I could just make h understand observers!
    var value = h('td', observer())
    observer(function (val) {
      value.innerHTML = val
    })
    return h('tr', h('th', observer.key), value)
  }

  var elements = {}

  function onEach (v, k) {
    if(white && !~white.indexOf(k)) return
    if(black &&  ~black.indexOf(k)) return

    //calling the template with false
    //means you can go
    //if(this) ... //update template
    //else //create template

    //so... a template is a function that creates or updates
    //an element.

    if(elements[k]) return

    var observe = observable.call(model, k)
    elements[k] = template(observe)

    /*
    var _el = elements[k]
    var el = template.call(v, k, _el || false
    if(!_el)
      table.appendChild(el)
    else if(el && el !== _el)
      table.replaceChild(el, elements[k])
    else if(!el)
      table.removeChild(_el)
    //else, do nothing, because the template updated the element itself
    elements[k] = el

    */
  }

  model.each(onEach)
  model.on('change', function (k, v) { onEach(v, k) })

  return table
}
